# Лабораторная работа №3. Навигация

## 1. Цель работы

Целью настоящей лабораторной работы является реализация полноценной навигации между экранами мобильного приложения, а также их объединение в единое пользовательское пространство. В частности, обучающиеся:

- ознакомятся с механизмами переходов между экранами (`Navigator`, `routes`, стек экранов);
- реализуют стартовый экран приложения (`splash page`);
- интегрируют ранее созданные экраны в навигационную архитектуру;
- получат практические навыки организации сложной структуры экранов, включая управление стеком внутри вкладок и отображение/скрытие элементов интерфейса в зависимости от контекста;
- выполнят индивидуальные задания по использованию сторонних библиотек для реализации навигации и состояния.

## 2. Общее описание

В предыдущей лабораторной работе была реализована основа пользовательского интерфейса приложения, включая отдельные экраны (список валют, новости, детальный экран) и локальное управление состоянием. Однако каждый из экранов существовал обособленно. В рамках данной работы предстоит объединить их в единое приложение с полноценной навигацией.

Применение механизмов навигации в Flutter позволяет пользователю перемещаться между экранами, возвращаться назад, а также запускать приложение с начального (`splash`) экрана.

В данной работе:

- будет реализована стартовая точка входа — **SplashPage**, отображающий логотип приложения;
- пользователь по завершении отображения `SplashPage` автоматически будет перенаправлен на главный экран (`HomePage`);
- навигация будет переведена с подхода на основе управления состоянием на встроенный навигационный механизм Flutter.

> ⚙️ В рамках данной лабораторной работы будет использоваться **императивный подход навигации на основе Navigator 1.0**, являющийся стандартным механизмом маршрутизации во Flutter. Он основан на управлении стеком экранов через методы `Navigator.push()` и `Navigator.pop()`, обеспечивая простоту реализации и контроль над переходами между экранами. 

## 3. Основная часть

В рамках данного раздела должно быть реализовано приложение, предоставляющее пользователю следующие переходы:

<img src="images/app.gif" alt="Splash Page" width="375"/>

### Splash Page

Во многих приложениях при запуске отображается так называемый "экран приветствия" — **Splash Page**. Его задача — предоставить пользователю мгновенную визуальную обратную связь и/или провести фоновую инициализацию приложения. Он реализуется в два этапа:

1. **Нативный Splash Screen**, отображаемый до запуска Flutter-движка. Настраивается через платформенные файлы (Android: `launch_background.xml`, iOS: `LaunchScreen.storyboard`) и обеспечивает мгновенную визуальную обратную связь при старте приложения.
2. **SplashPage средствами Flutter** — это экран, созданный как часть Flutter-интерфейса. Он отображается сразу после запуска движка и может использоваться для демонстрации логотипа, выполнения фоновой инициализации или подготовки данных перед переходом к основному интерфейсу (`HomePage`).

> ⚙️ В данной работе будет реализован второй этап — `SplashPage` средствами Flutter. В качестве самостоятельного задания предлагается также настроить нативный Splash Screen с использованием пакета [`flutter_native_splash`](https://pub.dev/packages/flutter_native_splash).

#### Верстка UI

В рамках этого подраздела необходимо сверстать splash-экран, отображающий логотип Flutter по центру.

<img src="images/splash_page.png" alt="Splash Page" width="375"/>

Перейдите в каталог `app` и создайте новый файл `splash_page.dart`.

```dart
import 'package:flutter/material.dart';

class SplashPage extends StatelessWidget {
  const SplashPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: FlutterLogo(size: 128),
      ),
      backgroundColor: Theme.of(context).primaryColor,
    );
  }
}
```

#### Подключение к точке входа в приложение

Для отображения Splash Page перед загрузкой главного экрана, необходимо внести изменения в `main.dart`. Откройте файл и замените свойство `home` на инициализацию через `FutureBuilder` с задержкой.

`FutureBuilder` — это виджет, позволяющий строить интерфейс на основе асинхронной операции (`Future`). Он отслеживает состояние выполнения `Future` и автоматически перестраивает интерфейс при изменении этого состояния.
Основная идея: пока асинхронная задача не завершена — отображается один виджет (например, экран загрузки), а после завершения — другой (основной интерфейс).


```dart
class App extends StatelessWidget {
  const App({super.key});

  Future<void> _initApp() async {
    // Имитируем задержку инициализации
    await Future.delayed(const Duration(seconds: 3));
  }

  @override
  Widget build(BuildContext context) {
    const primaryColor = Color(0xFF3929C7);
    const backgroundColor = Color(0xFFf2f2f2);
    const secondaryColor = Color(0xFF7F7F7F);

    return MaterialApp(
      theme: ThemeData(
        primaryColor: primaryColor,
        scaffoldBackgroundColor: backgroundColor,
        appBarTheme: AppBarTheme(
          backgroundColor: backgroundColor,
          titleTextStyle: TextStyle(
            fontFamily: 'Inter',
            fontSize: 16,
            color: Colors.black,
          ),
          centerTitle: true,
        ),
        bottomNavigationBarTheme: BottomNavigationBarThemeData(
          backgroundColor: Colors.white,
          selectedItemColor: primaryColor,
          unselectedItemColor: secondaryColor,
          selectedLabelStyle: TextStyle(
            fontFamily: 'Inter',
            fontSize: 12,
            color: primaryColor,
          ),
          unselectedLabelStyle: TextStyle(
            fontFamily: 'Inter',
            fontSize: 12,
            color: secondaryColor,
          ),
        ),
      ),
      home: FutureBuilder<void>(
        future: _initApp(),
        builder: (_, AsyncSnapshot<void> snapshot) {
          if (snapshot.connectionState == ConnectionState.done) {
            return const HomePage();
          }
          return const SplashPage();
        },
      ),
    );
  }
}
```

> ⚠️ Обратите внимание: в данной реализации `_initApp()` не выполняет фактической инициализации данных. В дальнейшем `Future.delayed(...)` можно заменить на реальную загрузку (например, загрузку данных из локальной или удалённой базы данных или проверку авторизации).

## 4. Интеграция встроенной навигации

На предыдущем этапе пользователь мог перемещаться между списком валют и детальным экраном с помощью самописной системы управления стеком экранов. Эта система была реализована через классы `CurrencyTabState` и `CurrencyTabContainer`, использующих `ChangeNotifier` и вручную управляемый список экранов.

Несмотря на то, что описанный подход работоспособен, он не считается рекомендуемым способом реализации навигации во Flutter:

- управление стеком экранов вручную требует значительных усилий при усложнении приложения;
- анимация переходов, возврат назад и системные жесты (например, свайп на iOS) не работают корректно;
- использование `ChangeNotifier` для отображения экранов нарушает принцип однозначной ответственности.

Во Flutter встроено решение для навигации — **Navigator**, основанный на стеке экранов. Использование `Navigator` позволяет:

- использовать `push()` и `pop()` для переходов между экранами;
- легко реализовать возврат назад;
- подключить анимацию переходов между экранами;
- взаимодействовать с системой на уровне платформы (включая аппаратные кнопки, свайпы и deep linking).

С учётом перехода на встроенную навигацию, реализованную с использованием **императивного подхода Navigator 1.0**, ранее созданная структура `currency_tab_container` становится избыточной и не соответствует декларативному стилю Flutter.

В связи с этим удалите папку `currency_tab_container`, включая файлы `currency_tab_container.dart` и `currency_tab_state.dart`, а также соответствующие импорты из других частей проекта.

> ℹ️ **Информация:** Flutter — в первую очередь **декларативный** фреймворк, однако он предоставляет возможность использовать **императивные** механизмы там, где это необходимо (например, для управления навигацией, анимациями и низкоуровневыми операциями).  

### Обновление `home.dart`

Замените использование `CurrencyTabContainer` на `CurrencyListPage`.

Убедитесь, что логика выбора вкладок и отображения текущей страницы осталась работоспособной.

### Обновление `currency_card.dart`

Для отображения детального экрана конкретной валюты замените вызов, связанный с пользовательским стеком, на встроенный вызов `Navigator`:

```dart
Navigator.push(
  context,
  MaterialPageRoute(builder: (_) => const CurrencyDetailPage(title: 'Австралийский доллар')),
);
```

### Обновление `currency_detail_page.dart`

Для возврата назад к предыдущему экрану используйте встроенный вызов `Navigator`:

```dart
Navigator.pop(context);
```

## 5. Самостоятельная часть

> Перед выполнением задания рекомендуется выбрать целевой уровень. Это поможет оптимизировать время и избежать необходимости переписывать архитектуру при переходе на более высокую оценку.

### Задание на оценку "3"

- Реализовать все компоненты, описанные в основной части лабораторной работы.
- Перевести навигацию приложения на использование **именованных маршрутов** (см. пособие, раздел 4.3).
- Подключить пакет [`flutter_native_splash`](https://pub.dev/packages/flutter_native_splash) и настроить **нативный Splash Page**, указав произвольный цвет фона и логотип приложения;
- Добавить в маршрутную схему **не менее двух дополнительных экранов**:
  - один из экранов должен возвращать результат выполнения - `Navigator.pop(context, result)`;
  - на экране, откуда происходит переход, необходимо обработать возвращаемое значение (например, отобразить его в `SnackBar`, текстом или другим произвольным способом на UI).

### Задание на оценку "4"

Дополнительно к предыдущим требованиям:

- Реализовать расширенные сценарии навигации с использованием встроенного механизма `Navigator 1.0`. В частности:
  - продемонстрировать работу с методами `pushNamedAndRemoveUntil`, `popUntil`, `maybePop`, `canPop`;
  - реализовать вызов модальных элементов: `dialog`, `modalBottomSheet`, `datePicker`, `timePicker` и уметь обрабатывать их результаты;
  - для одного из экранов реализовать передачу данных **в обоих направлениях** (например, передать аргументы при переходе на новый экран и получить результат при возврате обратно).

### Задание на оценку "5"

Дополнительно к предыдущим требованиям:

- Реализовать **кастомный анимационный переход** между двумя экранами (например, с использованием `PageRouteBuilder`);
- Добавить возможность возврата к корневому экрану из любого места в приложении (реализовать `popToRoot`).

> 🔁 **Что такое `popToRoot` в контексте навигации с табами?**  
>
> В приложениях с нижней навигацией (BottomNavigationBar) у каждой вкладки может быть свой собственный стек экранов.  
> 
> Например, пользователь во вкладке "Валюта" открыл несколько вложенных экранов. Если затем он переключился на другую вкладку и снова нажал на уже активную вкладку — ожидается, что стек этой вкладки **сбросится до корневого (начального) экрана**.